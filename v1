
```dataviewjs
// ==================================================
// BOOK OS: GLOBAL EDITION
// ==================================================

// --- 1. SETTINGS & CONSTANTS ---
const NO_POSTER_SVG = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='600' viewBox='0 0 400 600'%3E%3Crect width='400' height='600' fill='%231a1a1a'/%3E%3Cpath d='M200 250a50 50 0 0 0-50 50c0 27.6 22.4 50 50 50s50-22.4 50-50-22.4-50-50-50zm0 80c-16.5 0-30-13.5-30-30s13.5-30 30-30 30 13.5 30 30-13.5 30-30 30zm-80 90h160v20H120zm0-160h20v100h-20z' fill='%23333'/%3E%3Ctext x='50%25' y='75%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' font-size='14' fill='%23555' letter-spacing='2'%3ENO POSTER%3C/text%3E%3C/svg%3E";

const CONFIG = {  
    folder: '"Books"', // Movie data file path
    statusRead: "read",  
    statusList: "unread",  
    imagePlaceholder: NO_POSTER_SVG,  
    listsDbPath: "" // Enter any file path
};

const GenreColors = {
    "action": "#ef4444", "adventure": "#f97316", "autobiography": "#06b6d4",
    "comedy": "#eab308", "crime": "#71717a", "contemporary": "#8b5cf6",
    "fantasy": "#d946ef", "horror": "#9f1239", "mystery": "#64748b",
    "romance": "#ec4899", "sci-fi": "#10b981", "thriller": "#14b8a6",
    "Western": "#b45309", "historical": "#84cc16", "default": "#6366f1"
};

// --- 2. STATE MANAGEMENT ---
const initialState = {
    filter: 'all', search: '', sortMode: 'title', sortDir: 'asc',
    categoryMode: 'all', viewMode: 'grid', gridSize: 220,
    rangeLB: [0, 5], rangeMy: [0, 5], rangeYear: [1920, 2030],
    showMenu: false, innerViewMode: 'list'
};

// Deep copy for reset
let state = JSON.parse(JSON.stringify(initialState));

const app = dv.app;
const currentFilePath = this.currentFilePath;

// --- 3. ICONS ---
const Icons = {
    logo: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>`,
    search: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>`,
    close: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`,
    back: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>`,
    play: `<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="5 3 19 12 5 21 5 3"/></svg>`,
    star: `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>`,
    grid: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>`,
    timeline: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>`,
    layers: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>`,
    sort: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>`,
    check: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`,
    barcode: `<svg width="100%" height="30" viewBox="0 0 200 30" preserveAspectRatio="none" fill="currentColor"><path d="M2,0h2v30h-2z M6,0h4v30h-4z M12,0h2v30h-2z M18,0h4v30h-4z M24,0h2v30h-2z M30,0h6v30h-6z M40,0h2v30h-2z M44,0h4v30h-4z M50,0h2v30h-2z M56,0h4v30h-4z M64,0h6v30h-6z M74,0h2v30h-2z M78,0h4v30h-4z M84,0h2v30h-2z M90,0h4v30h-4z M96,0h2v30h-2z M102,0h6v30h-6z M110,0h2v30h-2z M114,0h4v30h-4z M120,0h2v30h-2z M124,0h2v30h-2z M130,0h6v30h-6z M140,0h2v30h-2z M144,0h4v30h-4z M150,0h2v30h-2z M156,0h4v30h-4z M164,0h2v30h-2z M170,0h6v30h-6z M180,0h2v30h-2z M184,0h4v30h-4z M192,0h2v30h-2z"/></svg>`,
    calendar: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>`,
    chart: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg>`,
    clock: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>`,
    text: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg>`,
    arrowUpDown: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><path d="m21 8-4-4-4 4"/><path d="M17 4v16"/></svg>`,
    filter: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>`,
    tag: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>`,
    reread: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`,
    list: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h.01"/><path d="M3 12h.01"/><path d="M3 18h.01"/></svg>`,
    plus: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>`,
    trash: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>`,
    minus: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"/></svg>`,
    x: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`,
    edit: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>`,
    alert: `<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>`,
    stats: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/></svg>`,
    tune: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/><line x1="17" y1="16" x2="23" y2="16"/></svg>`,
    shuffle: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="16" y1="3" x2="21" y2="3"/><line x1="21" y1="3" x2="21" y2="8"/><line x1="4" y1="20" x2="21" y2="3"/><line x1="21" y1="16" x2="21" y2="21"/><line x1="16" y1="21" x2="21" y2="21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>`,
    dice: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>`,
    refresh: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>`,
    pepper: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 17.5c2 2 5 2.5 7.5 1l9-9c.6-.6.6-1.5 0-2.1s-1.5-.6-2.1 0l-9 9c-1.5 2.5-1 5.5 1 7.5Z"/><path d="M18 7A5 5 0 0 1 13 2"/><path d="M22 1c-2 0-3 3-3 3"/></svg>`
};

const SortCriteria = [
    { id: 'title', label: 'Title', icon: Icons.text },
    { id: 'score', label: 'Score', icon: Icons.star },
    { id: 'scoreLB', label: 'LB Score', icon: Icons.chart },
    { id: 'created', label: 'Added', icon: Icons.calendar },
    { id: 'year', label: 'Year', icon: Icons.calendar },
    { id: 'runtimeMins', label: 'Pages', icon: Icons.clock }
];

// --- 5. HELPERS ---
function debounce(func, wait) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; }
function cleanText(raw) { if (!raw) return null; if (Array.isArray(raw)) return raw.map(cleanText).filter(x => x); if (typeof raw === 'object' && raw.path) return raw.display ? raw.display : raw.path.split('/').pop().replace('.md', ''); return String(raw).replace(/\[\[.*?\|(.*?)\]\]/g, '$1').replace(/\[\[(.*?)\]\]/g, '$1').trim(); }
function formatTotalRuntime(pages) { 
    return pages ? `${pages} pages` : "0 pages"; 
}
function formatLongDuration(pages) { 
    return pages ? `${pages.toLocaleString()} total pages` : "0 pages"; 
}
function getBadges(p) { const tags = (Array.isArray(p.tags) ? p.tags.join(' ') : (p.tags||'')) + ' ' + (p.quality||'') + ' ' + (p.tech||''); const lower = tags.toLowerCase(); const badges = []; if (lower.includes('4k') || lower.includes('uhd')) badges.push('4K'); if (lower.includes('hdr')) badges.push('HDR'); if (lower.includes('imax')) badges.push('IMAX'); if (lower.includes('atmos')) badges.push('ATMOS'); return badges; }
function formatDuration(raw) { 
    if (!raw || raw === 0) return "No Data"; 
    return `${raw} pages`; 
}
function parseDateSafe(input) { 
    if (!input) return null; 
    if (input.ts) return new Date(input.ts); 
    let str = String(input).replace(/\[\[|\]\]/g, '').trim();
    let date = new Date(str);
    if (!isNaN(date.getTime())) return date;
    return null; 
}

function formatDateDisplay(dateObj) { if (!dateObj) return ""; const d = new Date(dateObj); if (isNaN(d.getTime())) return ""; const day = String(d.getDate()).padStart(2, '0'); const month = String(d.getMonth() + 1).padStart(2, '0'); const year = d.getFullYear(); return `${day}-${month}-${year}`; }

// --- FILE OPERATIONS ---
async function updateFileStatus(filePath, newStatus) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            fm.status = newStatus;
            if (newStatus === CONFIG.statusRead) {
                const today = new Date().toISOString().split('T')[0];
                if (!fm.readDate) fm.readDate = [today];
                else if (Array.isArray(fm.readDate)) { if (!fm.readDate.includes(today)) fm.readDate.push(today); } 
                else { if (!String(fm.readDate).includes(today)) fm.readDate = [fm.readDate, today]; }
            }
        });
        new Notice(`Status updated.`);
        setTimeout(() => renderApp(), 300); 
    } catch (e) { console.error(e); new Notice("Update failed."); }
}

async function addRereadLog(filePath) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            const today = new Date().toISOString().split('T')[0];
            fm.status = CONFIG.statusRead; 
            if (!fm.readDate) fm.readDate = [today];
            else if (Array.isArray(fm.readDate)) fm.readDate.push(today);
            else fm.readDate = [fm.readDate, today];
        });
        new Notice("Re-read logged! üéâ");
        setTimeout(() => renderApp(), 300);
    } catch (e) { console.error(e); new Notice("Failed to log."); }
}

async function addListToMovie(filePath, listName, callback) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            if (!fm.lists) fm.lists = [listName];
            else if (Array.isArray(fm.lists)) { if (!fm.lists.includes(listName)) fm.lists.push(listName); }
            else { if (!String(fm.lists).includes(listName)) fm.lists = [fm.lists, listName]; }
        });
        if (callback) callback();
    } catch (e) { console.error(e); new Notice("Failed to add to shelf."); }
}

async function addSeriesToMovie(filePath, seriesName, callback) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            fm.series = seriesName;
        });
        new Notice(`Added to "${seriesName}".`);
        if (callback) callback();
    } catch (e) { console.error(e); new Notice("Failed to add to series."); }
}

async function removeListFromMovie(filePath, listName, callback) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            if (fm.lists) {
                if (Array.isArray(fm.lists)) {
                    fm.lists = fm.lists.filter(l => l !== listName);
                } else if (fm.lists === listName) {
                    fm.lists = [];
                }
            }
        });
        new Notice(`Removed from "${listName}".`);
        if (callback) callback();
    } catch (e) { console.error(e); new Notice("Failed to remove from shelf."); }
}

async function removeSeriesFromMovie(filePath, callback) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file) { new Notice("File not found!"); return; }
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            fm.series = null; 
        });
        new Notice(`Removed from series.`);
        if (callback) callback();
    } catch (e) { console.error(e); new Notice("Failed to remove series."); }
}

// --- COLLECTION OPERATIONS ---
async function updateCollectionDetails(oldName, newName, newCover) {
    const pages = dv.pages(CONFIG.folder).where(p => p.series === oldName);
    if (pages.length === 0) { new Notice("No books found in this series."); return; }
    
    let updatedCount = 0;
    for (let p of pages) {
        const file = app.vault.getAbstractFileByPath(p.file.path);
        try {
            await app.fileManager.processFrontMatter(file, (fm) => {
                if (newName && newName !== oldName) fm.series = newName;
                if (newCover) fm.series_cover = newCover;
            });
            updatedCount++;
        } catch (e) { console.error(`Failed to update ${p.file.name}`, e); }
    }
    
    if (updatedCount > 0) {
        new Notice(`Updated ${updatedCount} books in series.`);
        closeModal();
        setTimeout(() => renderApp(), 600); 
    }
}

async function createNewList(name, cover, desc) {
    const listFile = app.vault.getAbstractFileByPath(CONFIG.listsDbPath);
    if (!listFile) await app.vault.create(CONFIG.listsDbPath, "# Book OS Lists\n\n");
    const targetFile = app.vault.getAbstractFileByPath(CONFIG.listsDbPath);
    try {
        await app.fileManager.processFrontMatter(targetFile, (fm) => {
            if (!fm.lists) fm.lists = [];
            const id = Date.now().toString();
            fm.lists.push({ id: id, name: name, cover: cover || "", desc: desc || "" });
        });
        new Notice(`Shelf "${name}" created!`);
        closeModal();
        setTimeout(() => renderApp(), 300);
    } catch (e) { console.error(e); new Notice("Failed to create shelf."); }
}

async function updateListDetails(id, newName, newCover, newDesc) {
    const file = app.vault.getAbstractFileByPath(CONFIG.listsDbPath);
    if (!file) return;
    try {
        await app.fileManager.processFrontMatter(file, (fm) => {
            if (fm.lists && Array.isArray(fm.lists)) {
                const listIdx = fm.lists.findIndex(l => String(l.id) === String(id));
                if (listIdx > -1) {
                    fm.lists[listIdx].name = newName;
                    fm.lists[listIdx].cover = newCover;
                    fm.lists[listIdx].desc = newDesc;
                }
            }
        });
        new Notice("Shelf updated!");
        closeModal();
        setTimeout(() => renderApp(), 300);
    } catch (e) { console.error(e); new Notice("Failed to update shelf."); }
}

async function deleteList(listId, listName) {
    showCustomConfirm("DELETE SHELF", `Are you sure you want to delete "${listName}"? <br>This action cannot be undone.`, async () => {
        const file = app.vault.getAbstractFileByPath(CONFIG.listsDbPath);
        if (!file) { new Notice("DB File missing!"); return; }
        try {
            await app.fileManager.processFrontMatter(file, (fm) => {
                if (fm.lists && Array.isArray(fm.lists)) {
                    let targetIdx = -1;
                    if (listId) { targetIdx = fm.lists.findIndex(l => String(l.id) === String(listId)); }
                    if (targetIdx === -1 && listName) { targetIdx = fm.lists.findIndex(l => l.name === listName); }
                    if (targetIdx > -1) { fm.lists.splice(targetIdx, 1); new Notice(`Shelf deleted.`); } 
                    else { new Notice(`Shelf not found.`); }
                }
            });
            closeModal();
            setTimeout(() => renderApp(), 250);
            setTimeout(() => renderApp(), 600); // Double ensure refresh
        } catch (e) { console.error(e); new Notice("Failed to delete."); }
    });
}

function getSystemLists() {
    const page = dv.page(CONFIG.listsDbPath);
    if (!page || !page.lists) return [];
    return page.lists;
}

function calculateAnalytics(pages) {
    let totalRead = 0; let totalMins = 0; let totalScore = 0; let scoreCount = 0;
    const genres = {}; const authors = {}; const actors = {}; const years = {};
    pages.forEach(p => {
        const m = getMovieData(p);
        const status = String(m.status || "").toLowerCase();
        if (status.includes('read') || status.includes('izlendi') || m.readDates.length > 0) {
            totalRead++; totalMins += (m.runtimeMins || 0);
            if(m.score > 0) { totalScore += m.score; scoreCount++; }
            if(m.year) years[m.year] = (years[m.year] || 0) + 1;
            m.allGenres.forEach(g => { genres[g] = (genres[g] || 0) + 1; });
            if(m.author && m.author !== "Unknown") { let dirs = Array.isArray(m.author) ? m.author : String(m.author).split(',').map(s => s.trim()); dirs.forEach(d => { if(d) authors[d] = (authors[d] || 0) + 1; }); }
            if(m.tropes && m.tropes.length > 0) { m.tropes.forEach(a => { actors[a] = (actors[a] || 0) + 1; }); }
        }
    });
    const getTop = (obj, limit) => Object.entries(obj).sort((a,b) => b[1] - a[1]).slice(0, limit);
    const avgScore = scoreCount > 0 ? (totalScore / scoreCount).toFixed(1) : "0.0";
    
    // Calculate Top Year
    const topYearEntry = Object.entries(years).sort((a,b) => b[1] - a[1])[0];
    const topYear = topYearEntry ? topYearEntry[0] : "-";

    // SCALED: Get Top 8 items now instead of 5 for better filling
    return { 
        totalRead, totalDuration: formatLongDuration(totalMins), avgScore, topYear, 
        topGenres: getTop(genres, 8), 
        topAuthors: getTop(authors, 8), 
        topActors: getTop(actors, 8) 
    };
}

function getMovieData(page) {
    const p = page;
    const rawYear = p.year || p.Year || p.yil || p.release_date;
    const year = rawYear ? Number(String(rawYear).match(/\d{4}/)?.[0]) || 0 : 0;
// New logic to handle both numbers and stars in the 'rating' field
    let rawRating = p.rating || 0;
    let myScore = 0;

    if (typeof rawRating === 'string' && (rawRating.includes('‚òÖ') || rawRating.includes('‚òÜ'))) {
        // Count only the solid stars to get the numeric value
        myScore = (rawRating.match(/‚òÖ/g) || []).length;
    } else {
        myScore = Number(rawRating) || 0;
    }

    const lbScore = p.scoreLB || 0;
    const displayScore = Number(myScore) > 0 ? myScore : lbScore;    let created = p.created ? parseDateSafe(p.created) : new Date(p.file.ctime.ts); if (!created || isNaN(created.getTime())) created = new Date(p.file.ctime.ts);
    let released = p.release_date || p.released; if (released) released = parseDateSafe(released); if (!released) released = new Date(year, 0, 1); 
    let genreList = p.genre ? (Array.isArray(p.genre) ? p.genre : String(p.genre).split(',')) : (p.tags || []);
    genreList = genreList.map(cleanText).filter(g => g && !['movie','film','read','izlendi'].includes(g.toLowerCase()));
    let userLists = [];
    if (p.lists) {
        let rawLists = Array.isArray(p.lists) ? p.lists : String(p.lists).split(',');
        userLists = rawLists.map(l => { if (typeof l === 'object' && l.path) return l.path.replace('.md', ''); return String(l).trim(); }).filter(l => l && l !== "[object Object]" && l !== "undefined");
    }
    const mainGenre = genreList.length > 0 ? genreList[0] : "General";
    const displayGenres = genreList.length > 0 ? genreList.slice(0, 2).join(' ‚Ä¢ ') : mainGenre;
    const rawMainGenre = String(mainGenre).trim();
    const color = GenreColors[rawMainGenre] || GenreColors[rawMainGenre.split(' ')[0]] || GenreColors["default"];
    const author = cleanText(p.author) || "Unknown";
    const tropes = p.tropes ? (Array.isArray(p.tropes) ? p.tropes.map(cleanText) : [cleanText(p.tropes)]) : [];
    let readDates = [];
    if (p.readDate) {
        let rawLogs = p.readDate;
        if (typeof rawLogs === 'string' && rawLogs.includes(',')) rawLogs = rawLogs.split(',').map(s => s.trim()); else if (!Array.isArray(rawLogs)) rawLogs = [rawLogs];
        readDates = rawLogs.map(l => parseDateSafe(l)).filter(d => d !== null);
    }
    if (readDates.length === 0 && p.status === CONFIG.statusRead) readDates.push(created);
    const formattedReadDates = readDates.map(d => formatDateDisplay(d));
    let finalCover = p.cover; if (!finalCover || finalCover.length < 5) finalCover = CONFIG.imagePlaceholder;
    return {
        file: p.file, title: p.file.name, path: p.file.path, 
        cover: finalCover, seriesCover: p.series_cover || null,
        year, released, score: Number(myScore), scoreLB: Number(lbScore), displayScore: Number(displayScore).toFixed(1),
        pages: p.pageCount || 0, 
    runtimeMins: parseInt(p.pageCount) || 0, // Keep runtimeMins as a name to avoid breaking other logic
        mainGenre, displayGenres, allGenres: genreList, author, tropes, description: p.description || "No description available.", 
        status: p.status, series: cleanText(p.series) || null, created: created, color, badges: getBadges(p), 
        readDates: formattedReadDates, readDateObjs: readDates, userLists: userLists 
    };
}

function extractAllGenres(pages) {
    const genreSet = new Set();
    pages.forEach(p => {
        let genreList = p.genre ? (Array.isArray(p.genre) ? p.genre : String(p.genre).split(',')) : (p.tags || []);
        genreList.map(cleanText).filter(g => g && !['movie','film','read','izlendi'].includes(g.toLowerCase())).forEach(g => genreSet.add(g));
    });
    return Array.from(genreSet).sort();
}

function processUserLists(pages) {
    const listMap = {};
    const systemLists = getSystemLists(); 
    systemLists.forEach(l => { if(l.name === "[object Object]") return; listMap[l.name] = { name: l.name, id: l.id, movies: [], totalRuntime: 0, readCount: 0, meta: l }; });
    pages.forEach(p => {
        const m = getMovieData(p);
        if (m.userLists && m.userLists.length > 0) {
            m.userLists.forEach(listName => {
                if (!listName || listName === "[object Object]") return;
                if (!listMap[listName]) { listMap[listName] = { name: listName, id: null, movies: [], totalRuntime: 0, readCount: 0, meta: {} }; }
                listMap[listName].movies.push(m);
                listMap[listName].totalRuntime += m.runtimeMins;
                if(m.status === CONFIG.statusRead) listMap[listName].readCount++;
            });
        }
    });
    return Object.values(listMap).map(l => {
        let cover = l.meta.cover;
        if (!cover && l.movies.length > 0) { const randomMovie = l.movies[Math.floor(Math.random() * l.movies.length)]; cover = randomMovie.cover; }
        if (!cover) cover = CONFIG.imagePlaceholder;
        return {
            type: 'userList', id: l.id, title: l.name, count: l.movies.length,
            read: l.readCount, progress: l.movies.length > 0 ? Math.round((l.readCount / l.movies.length) * 100) : 0,
            movies: l.movies, cover: cover, desc: l.meta.desc || "",
            totalRuntime: formatTotalRuntime(l.totalRuntime), avgScore: l.movies.length > 0 ? (l.movies.reduce((acc, m) => acc + m.score, 0) / l.movies.length).toFixed(1) : "-",
            avgLB: l.movies.length > 0 ? (l.movies.reduce((acc, m) => acc + m.scoreLB, 0) / l.movies.length).toFixed(1) : "-", color: "#ec4899" 
        };
    });
}

function processItems(pages, sortMode, sortDir, viewMode, categoryMode) {
    if (state.filter === 'lists') { return [{ type: 'createListCard' }, ...processUserLists(pages)]; }
    if (viewMode === 'timeline') return null;
    let processedPages = pages;
    if (state.filter === CONFIG.statusRead) processedPages = pages.where(p => p.status === CONFIG.statusRead);
    else if (state.filter === 'list') processedPages = pages.where(p => !p.status || p.status !== CONFIG.statusRead); 
    
    // FILTERS: GENRES + TECH + SCORE (DUAL) + YEAR (DUAL)
    processedPages = processedPages.where(p => {
        const m = getMovieData(p);
        
        // 1. Category/Genre/Tech Filter
        let matchCat = true;
        if (categoryMode !== 'all' && categoryMode !== 'series') {
            let checkList = [...m.allGenres, ...m.badges];
            matchCat = checkList.includes(categoryMode);
        }
        
        // 2. Dual Range Filters
        // Range: [min, max]
        const matchLB = m.scoreLB >= state.rangeLB[0] && m.scoreLB <= state.rangeLB[1];
        const matchMy = m.score >= state.rangeMy[0] && m.score <= state.rangeMy[1];
        const matchYear = m.year >= state.rangeYear[0] && m.year <= state.rangeYear[1];

        return matchCat && matchLB && matchMy && matchYear;
    });

    let movies = processedPages.map(p => getMovieData(p));
    const groups = {}, singles = [];
    movies.forEach(m => { 
        if (m.series) { if (!groups[m.series]) groups[m.series] = []; groups[m.series].push(m); } 
        else singles.push({ type: 'movie', data: m }); 
    });
    const stacks = [];
    for (const [name, list] of Object.entries(groups)) {
        if (list.length > 1) {
            list.sort((a, b) => a.year - b.year);
            const specificCover = list.find(m => m.seriesCover);
            const stackCover = specificCover ? specificCover.seriesCover : list[0].cover;
            const rep = list[list.length-1];
            const wC = list.filter(m => m.status === CONFIG.statusRead).length;
            let totalMins = 0; let totalScore = 0; let scoreCount = 0; let totalLB = 0; let lbCount = 0;
            list.forEach(m => { totalMins += m.runtimeMins || 0; if(m.score > 0) { totalScore += m.score; scoreCount++; } if(m.scoreLB > 0) { totalLB += m.scoreLB; lbCount++; } });
            stacks.push({ 
                type: 'stack', title: name, count: list.length, 
                read: wC, progress: Math.round((wC/list.length)*100), 
                movies: list, cover: stackCover, sortKey: rep, color: rep.color,
                totalRuntime: formatTotalRuntime(totalMins), avgScore: scoreCount > 0 ? (totalScore / scoreCount).toFixed(1) : "-", avgLB: lbCount > 0 ? (totalLB / lbCount).toFixed(1) : "-"
            });
        } else { singles.push({ type: 'movie', data: list[0] }); }
    }
    let allItems = [...stacks, ...singles];
    if (categoryMode === 'series') allItems = allItems.filter(item => item.type === 'stack');
    allItems.sort((a, b) => {
        const getVal = (item) => { 
            const d = item.type === 'stack' || item.type === 'userList' ? (item.sortKey || item) : item.data; 
            if (!d) return 0;
            switch (sortMode) {
                case 'score': return d.score || 0;
                case 'scoreLB': return d.scoreLB || 0;
                case 'year': return d.year || 0;
                case 'runtimeMins': return d.runtimeMins || 0;
                case 'created': return d.created ? d.created.getTime() : 0;
                case 'title': default: return item.title || d.title || ""; 
            }
        };
        const valA = getVal(a); const valB = getVal(b);
        let comparison = 0; if (typeof valA === 'string' && typeof valB === 'string') comparison = valA.localeCompare(valB); else comparison = valA - valB;
        return sortDir === 'asc' ? comparison : -comparison;
    });
    return allItems;
}

// ==================================================
// --- 7. UI & NAVIGATION ---
// ==================================================

function closeModal() { 
    const bd = document.querySelector('.eth-modal-backdrop'); 
    if(bd) { bd.classList.remove('active'); setTimeout(() => bd.remove(), 200); } 
}

function showCustomConfirm(title, message, onConfirm) {
    const backdrop = document.createElement('div');
    backdrop.className = 'eth-modal-backdrop';
    backdrop.style.zIndex = "3000"; 
    backdrop.innerHTML = `<div class="eth-modal-panel alert-mode"><div class="alert-icon">${Icons.alert}</div><h2 class="alert-title">${title}</h2><p class="alert-msg">${message}</p><div class="alert-actions"><button class="action-btn" id="btn-cancel">CANCEL</button><button class="action-btn danger" id="btn-confirm">DELETE</button></div></div>`;
    document.body.appendChild(backdrop);
    requestAnimationFrame(() => backdrop.classList.add('active'));
    const closeAlert = () => { backdrop.classList.remove('active'); setTimeout(() => backdrop.remove(), 200); };
    backdrop.querySelector('#btn-cancel').onclick = (e) => { e.stopPropagation(); closeAlert(); };
    backdrop.onclick = (e) => { if(e.target === backdrop) closeAlert(); };
    backdrop.querySelector('#btn-confirm').onclick = async (e) => { e.stopPropagation(); e.target.innerHTML = "DELETING..."; await onConfirm(); closeAlert(); };
}

function openAnalyticsModal() {
    closeModal();
    setTimeout(() => {
        const backdrop = document.createElement('div');
        backdrop.className = 'eth-modal-backdrop';
        
        const allPages = dv.pages(CONFIG.folder).where(p => p.file.name !== "_BookOS_Lists");
        const data = calculateAnalytics(allPages);
        const maxGenreCount = data.topGenres.length > 0 ? data.topGenres[0][1] : 1;
        
        // NEW STRUCTURE: HERO CARDS + 3 COLUMN LISTS
        backdrop.innerHTML = `
        <div class="eth-modal-panel stats-mode wide-screen">
            <div class="nav-btn close-btn">${Icons.close}</div>
            <div class="stats-header"><h2>BOOK ANALYTICS</h2></div>
            
            <div class="stats-content">
                <!-- HERO CARDS -->
                <div class="stats-hero-grid">
                    <div class="stat-hero-card">
                        <div class="shc-val">${data.totalRead}</div>
                        <div class="shc-label">MOVIES</div>
                    </div>
                    <div class="stat-hero-card">
                        <div class="shc-val">${data.totalDuration}</div>
                        <div class="shc-label">TIME WATCHED</div>
                    </div>
                    <div class="stat-hero-card">
                        <div class="shc-val">${data.avgScore}</div>
                        <div class="shc-label">AVG SCORE</div>
                    </div>
                    <div class="stat-hero-card">
                        <div class="shc-val" style="color:var(--accent);">${data.topYear}</div>
                        <div class="shc-label">FAVORITE YEAR</div>
                    </div>
                </div>

                <!-- DASHBOARD LISTS -->
                <div class="stats-dashboard-grid">
                    
                    <!-- COL 1: TOP GENRES (BARS) -->
                    <div class="stat-panel">
                        <h3>TOP GENRES</h3>
                        <div class="simple-list">
                            ${data.topGenres.map(g => {
                                const pct = Math.round((g[1] / maxGenreCount) * 100);
                                return `
                                <div class="bar-row">
                                    <span class="bar-label">${g[0]}</span>
                                    <div class="bar-track"><div class="bar-fill" style="width:${pct}%"></div></div>
                                    <span class="bar-count">${g[1]}</span>
                                </div>`;
                            }).join('')}
                        </div>
                    </div>

                    <!-- COL 2: TOP AUTHORS (RANK LIST) -->
                    <div class="stat-panel">
                        <h3>TOP AUTHORS</h3>
                        <div class="simple-list">
                            ${data.topAuthors.map((d,i) => `
                            <div class="sl-row">
                                <span class="sl-rank">${i+1}</span>
                                <span class="sl-name">${d[0]}</span>
                                <span class="sl-count">${d[1]}</span>
                            </div>`).join('')}
                        </div>
                    </div>

                    <!-- COL 3: TOP ACTORS (RANK LIST) -->
                    <div class="stat-panel">
                        <h3>TOP ACTORS</h3>
                        <div class="simple-list">
                            ${data.topActors.map((d,i) => `
                            <div class="sl-row">
                                <span class="sl-rank">${i+1}</span>
                                <span class="sl-name">${d[0]}</span>
                                <span class="sl-count">${d[1]}</span>
                            </div>`).join('')}
                        </div>
                    </div>

                </div>
            </div>
        </div>`;
        
        document.body.appendChild(backdrop);
        requestAnimationFrame(() => backdrop.classList.add('active'));
        backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); closeModal(); };
        backdrop.onclick = (e) => { if(e.target === backdrop) closeModal(); };
    }, 50);
}

function openMovieSelectorModal(targetName, onAddCallback, mode = 'list') {
    const selectorBackdrop = document.createElement('div');
    selectorBackdrop.className = 'eth-modal-backdrop selector-mode';
    
    // FORCE HIGHER Z-INDEX TO FIX OVERLAP ISSUE
    selectorBackdrop.style.zIndex = "2300"; 
    
    const allMovies = dv.pages(CONFIG.folder).where(p => p.file.name !== "_BookOS_Lists").map(p => getMovieData(p)).sort((a,b) => a.title.localeCompare(b.title));
    selectorBackdrop.innerHTML = `<div class="eth-modal-panel selector-panel"><div class="selector-header"><h3>Add to "${targetName}"</h3><div class="selector-search">${Icons.search}<input type="text" id="movie-selector-search" placeholder="Search movies..."></div><div class="nav-btn close-btn-selector">${Icons.close}</div></div><div class="selector-grid" id="movie-selector-grid"></div></div>`;
    document.body.appendChild(selectorBackdrop);
    requestAnimationFrame(() => selectorBackdrop.classList.add('active'));
    const grid = selectorBackdrop.querySelector('#movie-selector-grid');
    const searchInput = selectorBackdrop.querySelector('#movie-selector-search');
    
    const renderMovies = (filterText = "") => {
        grid.innerHTML = "";
        const filtered = allMovies.filter(m => m.title.toLowerCase().includes(filterText.toLowerCase()));
        filtered.forEach(m => {
            const item = document.createElement('div'); item.className = 'selector-item';
            let isAdded = false;
            if (mode === 'list') {
                isAdded = m.userLists && m.userLists.includes(targetName);
            } else if (mode === 'series') {
                isAdded = m.series === targetName;
            }
            
            item.innerHTML = `<div class="si-poster" style="background-image: url('${m.cover}')"></div><div class="si-info"><div class="si-title">${m.title}</div><div class="si-year">${m.year}</div></div><div class="si-action">${isAdded ? Icons.check : Icons.plus}</div>`;
            
            if (isAdded) {
                item.classList.add('added');
            } else { 
                item.onclick = async () => { 
                    item.classList.add('loading'); 
                    const finishAdd = async () => {
                        item.classList.remove('loading'); 
                        item.classList.add('added'); 
                        item.querySelector('.si-action').innerHTML = Icons.check; 
                        item.onclick = null; 
                    };
                    
                    if (mode === 'list') {
                        await addListToMovie(m.path, targetName, finishAdd); 
                    } else {
                        await addSeriesToMovie(m.path, targetName, finishAdd);
                    }
                }; 
            }
            grid.appendChild(item);
        });
    };
    renderMovies();
    searchInput.oninput = (e) => renderMovies(e.target.value);
    selectorBackdrop.querySelector('.close-btn-selector').onclick = async () => { selectorBackdrop.classList.remove('active'); setTimeout(() => { selectorBackdrop.remove(); }, 200); if(onAddCallback) await onAddCallback(); };
}

function openCreateListModal() {
    closeModal();
    setTimeout(() => {
        const backdrop = document.createElement('div');
        backdrop.className = 'eth-modal-backdrop';
        backdrop.innerHTML = `<div class="eth-modal-panel create-list-mode"><div class="nav-btn close-btn">${Icons.close}</div><div class="create-form-container"><h2>CREATE NEW SHELF</h2><div class="input-group"><label>SHELF NAME</label><input type="text" id="list-name-input" placeholder="e.g.: Horror Favorites"></div><div class="input-group"><label>COVER IMAGE (URL)</label><input type="text" id="list-cover-input" placeholder="https://..."></div><div class="input-group"><label>DESCRIPTION</label><textarea id="list-desc-input" rows="3" placeholder="What is this shelf about?"></textarea></div><button id="btn-create-list" class="action-btn primary">CREATE</button></div></div>`;
        document.body.appendChild(backdrop);
        requestAnimationFrame(() => backdrop.classList.add('active'));
        backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); closeModal(); };
        backdrop.onclick = (e) => { if(e.target === backdrop) closeModal(); };
        backdrop.querySelector('#btn-create-list').onclick = () => { const name = document.getElementById('list-name-input').value; const cover = document.getElementById('list-cover-input').value; const desc = document.getElementById('list-desc-input').value; if (!name) { new Notice("Please enter a shelf name."); return; } createNewList(name, cover, desc); };
    }, 50);
}

function openEditListModal(id, currentName, currentCover, currentDesc) {
    const backdrop = document.createElement('div');
    backdrop.className = 'eth-modal-backdrop';
    backdrop.innerHTML = `<div class="eth-modal-panel create-list-mode" style="z-index:2200"><div class="nav-btn close-btn">${Icons.close}</div><div class="create-form-container"><h2>EDIT SHELF</h2><div class="input-group"><label>SHELF NAME</label><input type="text" id="list-name-input" value="${currentName}"></div><div class="input-group"><label>COVER IMAGE (URL)</label><input type="text" id="list-cover-input" value="${currentCover}"></div><div class="input-group"><label>DESCRIPTION</label><textarea id="list-desc-input" rows="3">${currentDesc}</textarea></div><button id="btn-save-list" class="action-btn primary">SAVE CHANGES</button></div></div>`;
    document.body.appendChild(backdrop);
    requestAnimationFrame(() => backdrop.classList.add('active'));
    backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); backdrop.classList.remove('active'); setTimeout(() => backdrop.remove(), 200); };
    backdrop.querySelector('#btn-save-list').onclick = () => { const name = document.getElementById('list-name-input').value; const cover = document.getElementById('list-cover-input').value; const desc = document.getElementById('list-desc-input').value; if (!name) { new Notice("List name is required."); return; } updateListDetails(id, name, cover, desc); backdrop.classList.remove('active'); setTimeout(() => backdrop.remove(), 200); };
}

function openEditCollectionModal(currentName, currentCover) {
    const backdrop = document.createElement('div');
    backdrop.className = 'eth-modal-backdrop';
    backdrop.innerHTML = `<div class="eth-modal-panel create-list-mode" style="z-index:2200"><div class="nav-btn close-btn">${Icons.close}</div><div class="create-form-container"><h2>EDIT SERIES</h2><div class="input-group"><label>SERIES NAME</label><input type="text" id="col-name-input" value="${currentName}"></div><div class="input-group"><label>COVER IMAGE (URL)</label><input type="text" id="col-cover-input" value="${currentCover || ''}" placeholder="Leave empty to use movie poster"></div><div class="input-group"><p style="font-size:0.75rem; color:#666;">Note: Renaming will update the 'series' field for all books in this series.</p></div><button id="btn-save-col" class="action-btn primary">SAVE CHANGES</button></div></div>`;
    document.body.appendChild(backdrop);
    requestAnimationFrame(() => backdrop.classList.add('active'));
    backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); backdrop.classList.remove('active'); setTimeout(() => backdrop.remove(), 200); };
    backdrop.querySelector('#btn-save-col').onclick = () => { const name = document.getElementById('col-name-input').value; const cover = document.getElementById('col-cover-input').value; if (!name) { new Notice("Series name is required."); return; } updateCollectionDetails(currentName, name, cover); backdrop.classList.remove('active'); setTimeout(() => backdrop.remove(), 200); };
}

function openMovieModal(m, parentStack = null) {
    closeModal();
    setTimeout(() => {
        const backdrop = document.createElement('div');
        backdrop.className = 'eth-modal-backdrop';
        const tropesHtml = m.tropes.length > 0 ? `<div class="eth-chips-grid">${m.tropes.slice(0, 12).map(c => `<div class="chip">‚óè ${c}</div>`).join('')}</div>` : `<span class="muted-text">No tropes info.</span>`;
        const badgeHtml = m.badges.map(b => `<span class="badge">${b}</span>`).join('');
        const logHtml = m.readDates.length > 0 ? `<div class="log-box"><div class="log-head">READING LOG</div>${m.readDates.map(d => `<div class="log-row"><span>${Icons.check}</span> ${d}</div>`).join('')}</div>` : '';
        const prettyRuntime = formatDuration(m.pages);
        const dateAdded = m.created ? formatDateDisplay(m.created) : "Unknown";
        const backButton = parentStack ? `<button class="nav-btn back-btn" title="Go Back">${Icons.back} <span>Back</span></button>` : '';
        const isRead = m.status === CONFIG.statusRead;
        const btnStatusHtml = `<div class="status-control-row"><button id="btn-status-toggle" class="status-indicator ${isRead ? 'read' : 'list'}" data-path="${m.path}">${isRead ? 'READ' : 'TO BE READ'}</button><button id="btn-reread" class="reread-btn" title="Logged Re-Read">${Icons.reread}</button></div>`;
        backdrop.innerHTML = `<div class="eth-modal-panel movie-mode wide-screen"><div class="panel-bg" style="background-image: url('${m.cover}')"></div><div class="panel-overlay"></div><div class="panel-nav">${backButton}<button class="nav-btn close-btn">${Icons.close}</button></div><div class="panel-content"><div class="p-col-left"><img src="${m.cover}" class="poster-frame" />${m.score > 0 ? `<div class="poster-rating-badge"><span class="pr-label">MY RATING</span><div class="pr-val">${Icons.star} ${m.score} ${Icons.pepper} ${m.spicerating}</div></div>` : ''}</div><div class="p-col-center"><div class="meta-tags-hero">${m.displayGenres.split('‚Ä¢').map(g => `<span class="hero-tag">${g.trim()}</span>`).join('')}</div><h1 class="movie-title">${m.title}</h1><div class="info-grid"><div class="info-item"><span class="ii-label">PAGES</span><span class="ii-val">${prettyRuntime}</span></div><div class="info-item"><span class="ii-label">YEAR</span><span class="ii-val">${m.year}</span></div></div><div class="eth-plot-box"><p class="movie-plot">${m.description}</p></div><div class="section-title">TROPES</div>${tropesHtml}</div><div class="p-col-right"><div class="ticket-card full-info"><div class="tc-header" style="background:${m.color}">BOOK TICKET</div><div class="tc-body"><div class="tc-data-group"><div class="tc-row signature-row"><span>AUTHOR</span><div class="director-sign">${m.author}</div></div><div class="tc-row"><span>DATE ADDED</span><b>${dateAdded}</b></div><br><div class="tc-status-area">${btnStatusHtml}${logHtml}</div></div><div class="tc-footer"><div class="barcode-mini">${Icons.barcode}</div><button id="btn-open-note" class="action-btn">OPEN NOTE</button></div></div></div></div></div>`;
        document.body.appendChild(backdrop);
        requestAnimationFrame(() => backdrop.classList.add('active'));
        backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); closeModal(); };
        backdrop.onclick = (e) => { if(e.target === backdrop) closeModal(); };
        backdrop.querySelector('#btn-open-note').onclick = (e) => { e.stopPropagation(); closeModal(); app.workspace.openLinkText(m.file.path, currentFilePath); };
        const btnToggle = backdrop.querySelector('#btn-status-toggle'); btnToggle.onclick = async (e) => { e.stopPropagation(); const newStatus = m.status === CONFIG.statusRead ? CONFIG.statusList : CONFIG.statusRead; btnToggle.textContent = "Updating..."; btnToggle.style.opacity = "0.7"; await updateFileStatus(m.path, newStatus); closeModal(); };
        const btnReread = backdrop.querySelector('#btn-reread'); btnReread.onclick = async (e) => { e.stopPropagation(); btnReread.innerHTML = Icons.check; await addRereadLog(m.path); closeModal(); };
        if(parentStack) { backdrop.querySelector('.back-btn').onclick = (e) => { e.stopPropagation(); closeModal(); setTimeout(() => openSeriesModal(parentStack), 250); }; }
    }, 50);
}

function openSeriesModal(stack) {
    closeModal();
    setTimeout(() => {
        const backdrop = document.createElement('div');
        const isUserList = stack.type === 'userList';
        const extraClass = isUserList ? 'is-user-list' : ''; 
        backdrop.className = `eth-modal-backdrop ${extraClass}`;
        const isGrid = state.innerViewMode === 'grid';
        let contentHtml = '';
        if (stack.movies.length === 0) { contentHtml = `<div class="eth-empty-state" style="padding: 50px;">This shelf is empty.<br>${isUserList ? `<button id="btn-add-movie-empty" class="action-btn" style="margin-top:20px; width:auto;">+ Add Movie</button>` : 'Add "lists: '+stack.title+'" property to your movies.'}</div>`; } 
        else {
            if(isGrid) {
                // FIXED: Better delete button for mini-cards
                contentHtml = `<div class="cl-grid-container">` + stack.movies.map(m => `
                <div class="eth-card mini-card" onclick="openMovieModalFromSeries('${m.path}', '${stack.title}')">
                    <div class="eth-card-cover" style="background-image: url('${m.cover}')">
                        <div class="eth-rating-badge" style="top:6px; right:6px; font-size:0.6rem; padding:3px 6px;">${m.score}</div>
                        <div class="mini-card-delete-btn" title="Remove" onclick="removeMovieHandler(event, '${m.path}', '${stack.title}', ${isUserList})">${Icons.x}</div>
                    </div>
                    <div class="eth-card-meta"><div class="title" style="font-size:0.8rem;">${m.title}</div></div>
                </div>`).join('') + `</div>`;
            } else {
                contentHtml = stack.movies.map((m, i) => `<div class="collection-row" data-idx="${i}"><div class="cr-left"><div class="cr-index">${i + 1}</div><div class="cr-poster" style="background-image: url('${m.cover}')"></div></div><div class="cr-mid"><div class="cr-head"><div class="cr-title">${m.title}</div><div class="cr-year">${m.year}</div></div><div class="cr-plot">${m.description.substring(0, 110)}${m.description.length > 110 ? '...' : ''}</div><div class="cr-tags"><span class="pill time">${formatDuration(m.runtime)}</span>${m.score > 0 ? `<span class="pill star">‚òÖ ${m.score}</span>` : ''}</div></div><div class="cr-right"><div class="cr-status-icon ${m.status === CONFIG.statusRead ? 'is-read' : ''}">${m.status === CONFIG.statusRead ? Icons.check : Icons.play}</div><div class="cr-remove-btn" title="Remove" onclick="removeMovieHandler(event, '${m.path}', '${stack.title}', ${isUserList})">${Icons.trash}</div></div></div>`).join('');
            }
        }
        const labelText = isUserList ? "USER LIST" : "SERIES";
        
        let sidebarActions = `<div style="display:flex; gap:10px; margin-bottom:20px;">
            <button id="btn-add-movie-sidebar" class="action-btn" style="flex:1;">+ Add Movie</button>
            ${isUserList 
                ? `<button id="btn-edit-list" class="action-btn" style="width:50px; padding:0; display:flex; align-items:center; justify-content:center;">${Icons.edit}</button>` 
                : `<button id="btn-edit-collection" class="action-btn" style="width:50px; padding:0; display:flex; align-items:center; justify-content:center;">${Icons.edit}</button>`
            }
        </div>`;

        const viewToggleBtn = `<button class="nav-btn view-toggle-btn" title="Toggle View" style="position:absolute; top:30px; right:40px; z-index:50;">${isGrid ? Icons.list : Icons.grid}</button>`;
        
        // REMOVED <span class="cl-h-count">...</span> from header to clean up UI
        backdrop.innerHTML = `<div class="eth-modal-panel collection-mode"><div class="panel-bg" style="background-image: url('${stack.cover}')"></div><div class="panel-overlay"></div><button class="nav-btn close-btn floating" style="z-index:51;">${Icons.close}</button>${viewToggleBtn}<div class="collection-layout"><div class="cl-sidebar"><div class="cl-poster-wrapper"><div class="cl-poster-card"><div class="cl-poster" style="background-image: url('${stack.cover}')"></div><div class="cl-tag">${labelText}</div></div></div><div class="cl-meta-block"><h1 class="cl-title">${stack.title}</h1>${sidebarActions}<div class="cl-stats-grid"><div class="cl-stat-box"><div class="cl-stat-icon">${Icons.clock}</div><div class="cl-stat-val">${stack.totalRuntime}</div><div class="cl-stat-label">Pages</div></div><div class="cl-stat-box"><div class="cl-stat-icon">${Icons.star}</div><div class="cl-stat-val">${stack.avgScore}</div><div class="cl-stat-label">Score</div></div>${!isUserList ? `<div class="cl-stat-box"><div class="cl-stat-icon">${Icons.chart}</div><div class="cl-stat-val">${stack.avgLB}</div><div class="cl-stat-label">LB</div></div>` : ''}</div><div class="cl-progress-card"><div class="stat-row"><span>Progress</span><b>${stack.read} / ${stack.count}</b></div><div class="stat-bar"><div class="stat-fill" style="width:${stack.progress}%; background:${stack.color}"></div></div></div></div></div><div class="cl-content-wrapper"><div class="cl-header-sticky"><span class="cl-h-title">SHLEVED BOOKS</span></div><div class="cl-scroll-area ${isGrid ? 'grid-layout' : 'list-layout'}">${contentHtml}</div></div></div></div>`;
        document.body.appendChild(backdrop);
        requestAnimationFrame(() => backdrop.classList.add('active'));
        backdrop.querySelector('.view-toggle-btn').onclick = (e) => { e.stopPropagation(); state.innerViewMode = state.innerViewMode === 'grid' ? 'list' : 'grid'; closeModal(); setTimeout(() => openSeriesModal(stack), 250); };
        if (stack.movies.length > 0 && !isGrid) {
            const scrollBox = backdrop.querySelector('.cl-scroll-area');
            scrollBox.addEventListener('click', (e) => { 
                const row = e.target.closest('.collection-row'); 
                if (row && !e.target.closest('.cr-remove-btn')) { e.stopPropagation(); const idx = parseInt(row.dataset.idx); closeModal(); setTimeout(() => openMovieModal(stack.movies[idx], stack), 250); } 
            });
        }
        window.openMovieModalFromSeries = (path, stackTitle) => { const page = app.metadataCache.getFirstLinkpathDest(path, ""); const m = getMovieData({file: page, ...dv.page(path)}); openMovieModal(m, stack); };
        window.removeMovieHandler = async (e, path, stackName, isUserList) => { e.stopPropagation(); const msg = isUserList ? `Remove book from "${stackName}"?` : `Remove book from "${stackName}" series?`; showCustomConfirm("REMOVE BOOK", msg, async () => { const callback = async () => { await renderApp(); const allPages = dv.pages(CONFIG.folder).where(p => p.file.name !== "_BookOS_Lists"); let updatedStack; if (isUserList) { const updatedLists = processUserLists(allPages); updatedStack = updatedLists.find(l => l.title === stackName); } else { const items = processItems(allPages, state.sortMode, state.sortDir, state.viewMode, 'all'); updatedStack = items.find(i => i.type === 'stack' && i.title === stackName); } if(updatedStack) { closeModal(); setTimeout(() => openSeriesModal(updatedStack), 300); } else { closeModal(); renderApp(); } }; if (isUserList) { await removeListFromMovie(path, stackName, callback); } else { await removeSeriesFromMovie(path, callback); } }); };
        
        const btnAddSidebar = backdrop.querySelector('#btn-add-movie-sidebar'); 
        const btnAddEmpty = backdrop.querySelector('#btn-add-movie-empty'); 
        const btnEditList = backdrop.querySelector('#btn-edit-list');
        const btnEditCollection = backdrop.querySelector('#btn-edit-collection');
        
        const triggerAdd = () => openMovieSelectorModal(stack.title, async () => { 
            await renderApp(); 
            const allPages = dv.pages(CONFIG.folder).where(p => p.file.name !== "_BookOS_Lists"); 
            let updatedStack;
            if (isUserList) {
                const updatedLists = processUserLists(allPages); 
                updatedStack = updatedLists.find(l => l.title === stack.title); 
            } else {
                const items = processItems(allPages, state.sortMode, state.sortDir, state.viewMode, 'all'); 
                updatedStack = items.find(i => i.type === 'stack' && i.title === stack.title);
            }
            if(updatedStack) { closeModal(); setTimeout(() => openSeriesModal(updatedStack), 300); } 
        }, isUserList ? 'list' : 'series');
        
        if (btnAddSidebar) btnAddSidebar.onclick = triggerAdd; 
        if (btnAddEmpty) btnAddEmpty.onclick = triggerAdd; 
        if (btnEditList) btnEditList.onclick = () => { openEditListModal(stack.id, stack.title, stack.cover, stack.desc); };
        if (btnEditCollection) btnEditCollection.onclick = () => { openEditCollectionModal(stack.title, stack.movies[0].seriesCover); };
        
        backdrop.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); closeModal(); };
        backdrop.onclick = (e) => { if(e.target === backdrop) closeModal(); };
    }, 50);
}

// ... RENDER & INIT ...
const root = this.container;
root.innerHTML = ""; root.className = "eth-ui-wrapper";
const ambientBg = root.createEl("div", { cls: "eth-ambient-bg" });
let rawPages = dv.pages(CONFIG.folder).where(p => p.file.name !== "_BookOS_Lists"); 
const availableGenres = extractAllGenres(rawPages); 
const techFilters = ['4K', 'HDR', 'IMAX', 'ATMOS'];

const headerWrapper = root.createEl("div", { cls: "eth-header-wrapper" });
const navIsland = headerWrapper.createEl("div", { cls: "eth-nav-island floating-hud" });

// LEFT: BRAND
const navLeft = navIsland.createEl("div", { cls: "nav-grp start brand-area" });
// const logo = navLeft.createEl("div", { cls: "eth-logo-mini" }); logo.innerHTML = Icons.logo; 
// const brandTitle = navLeft.createEl("div", { cls: "eth-brand-title", text: "Book OS" });

// CENTER: UNIFIED SEARCH & SEGMENTED CONTROL
const navCenter = navIsland.createEl("div", { cls: "nav-grp center control-deck" });
const searchAndFilter = navCenter.createEl("div", { cls: "search-and-filter-group" });

// Search Input
const searchInputEl = searchAndFilter.createEl("div", { cls: "modern-search-input" });
searchInputEl.innerHTML = `<div class="search-icon">${Icons.search}</div><input type="text" placeholder="Search movies..." value="${state.search}">`;
const realInput = searchInputEl.querySelector('input');
realInput.oninput = (e) => { state.search = e.target.value; debouncedRender(); };

// Segmented Control
const segmentedWrap = searchAndFilter.createEl("div", { cls: "eth-segmented-control" });
const createSegBtn = (txt, id) => { 
    const btn = segmentedWrap.createEl("button", { text: txt, cls: `eth-seg-btn ${state.filter === id ? 'active' : ''}` }); 
    btn.onclick = (e) => { 
        state.filter = id; 
        segmentedWrap.querySelectorAll('.eth-seg-btn').forEach(b => b.classList.remove('active')); 
        btn.classList.add('active'); 
        renderApp(); 
    }; 
    return btn; 
};
createSegBtn("All", 'all'); createSegBtn("Read", CONFIG.statusRead); createSegBtn("Shelves", 'lists');

// RIGHT: TOOLS
const navRight = navIsland.createEl("div", { cls: "nav-grp end tool-kit" });
const btnRandom = navRight.createEl("button", { cls: "eth-hud-btn icon-only", title: "Shuffle / Random Book" });
btnRandom.innerHTML = Icons.dice;
btnRandom.onclick = () => { const validMovies = rawPages.map(p => getMovieData(p)).filter(m => m.status !== CONFIG.statusRead); if(validMovies.length > 0) { const rand = validMovies[Math.floor(Math.random() * validMovies.length)]; openMovieModal(rand); } else { new Notice("No books to read!"); } };
const statsBtn = navRight.createEl("button", { cls: "eth-hud-btn icon-only", title: "Analytics" });
statsBtn.innerHTML = Icons.stats;
statsBtn.onclick = () => openAnalyticsModal();
const btnViewMenu = navRight.createEl("button", { cls: `eth-hud-btn icon-only menu-trigger ${state.showMenu ? 'active' : ''}`, title: "View & Settings" });
btnViewMenu.innerHTML = Icons.tune;
btnViewMenu.onclick = (e) => { e.stopPropagation(); state.showMenu = !state.showMenu; viewMenu.classList.toggle('active', state.showMenu); btnViewMenu.classList.toggle('active', state.showMenu); };

// --- MENU CONSTRUCTION (NEW GRID LAYOUT) ---
const viewMenu = headerWrapper.createEl("div", { cls: `eth-view-menu ${state.showMenu ? 'active' : ''}` });
viewMenu.onclick = (e) => e.stopPropagation(); 

// MENU HEADER
const menuHeader = viewMenu.createEl("div", { cls: "menu-header-row" });
menuHeader.innerHTML = `<span class="menu-header-title">CONTROL PANEL</span><div class="menu-actions"><button class="menu-action-btn reset-btn" title="Reset All Filters">${Icons.refresh}</button><div class="menu-close-btn">${Icons.x}</div></div>`;
menuHeader.querySelector('.menu-close-btn').onclick = () => { state.showMenu = false; updateMenuVisuals(); };
menuHeader.querySelector('.reset-btn').onclick = () => {
    state = JSON.parse(JSON.stringify(initialState));
    state.showMenu = true; 
    realInput.value = ""; 
    segmentedWrap.querySelectorAll('.eth-seg-btn').forEach(b => b.classList.remove('active'));
    segmentedWrap.querySelector('.eth-seg-btn').classList.add('active');
    
    viewMenu.querySelectorAll('.range-min').forEach(i => {
       if(i.nextElementSibling.classList.contains('range-max')) { 
           if(i.max == "5") i.value = 0; else i.value = 1920; 
       }
    });
    viewMenu.querySelectorAll('.range-max').forEach(i => {
       if(i.max == "5") i.value = 5; else i.value = 2030;
    });
    
    updateMenuVisuals();
    renderApp();
    new Notice("Filters Reset");
};

// WRAPPER FOR GRID LAYOUT
const menuContentGrid = viewMenu.createEl("div", { cls: "menu-grid-layout" });

// LEFT COL: APPEARANCE
const leftCol = menuContentGrid.createEl("div", { cls: "menu-column" });
const vmGroupApp = leftCol.createEl("div", { cls: "menu-group" });
vmGroupApp.createEl("div", { cls: "menu-label", text: "APPEARANCE" });

// View Toggle Button (Wide)
const viewToggle = vmGroupApp.createEl("button", { cls: "menu-btn toggle-view-btn full-width" });
viewToggle.innerHTML = `${state.viewMode === 'grid' ? Icons.timeline : Icons.grid} <span>${state.viewMode === 'grid' ? 'Switch to Timeline' : 'Switch to Grid'}</span>`;
viewToggle.onclick = () => { state.viewMode = state.viewMode === 'grid' ? 'timeline' : 'grid'; updateMenuVisuals(); renderApp(); };

// Slider
const sliderContainer = vmGroupApp.createEl("div", { cls: "slider-container-labeled" });
sliderContainer.innerHTML = `<div class="slider-label-tiny">CARD SIZE</div><div class="menu-slider-wrap"><input type="range" min="150" max="350" value="${state.gridSize}" step="10"></div>`;
const sliderGroup = sliderContainer.querySelector('.menu-slider-wrap');

// RIGHT COL: SORT
const rightCol = menuContentGrid.createEl("div", { cls: "menu-column" });
const vmGroupSort = rightCol.createEl("div", { cls: "menu-group" });
vmGroupSort.createEl("div", { cls: "menu-label", text: "SORT BY" });
const rowSort = vmGroupSort.createEl("div", { cls: "menu-grid-buttons" });
SortCriteria.forEach(crit => { 
    const btn = rowSort.createEl("button", { cls: `menu-chip sort-btn ${state.sortMode === crit.id ? 'active' : ''}`, attr: {'data-id': crit.id} }); 
    btn.innerHTML = `${crit.icon} ${crit.label}`; 
    btn.onclick = () => { state.sortMode = crit.id; updateMenuVisuals(); renderApp(); }; 
});
// Direction Button (Independent)
const dirBtn = rowSort.createEl("button", { cls: `menu-chip icon-only sort-dir-btn ${state.sortDir === 'desc' ? 'active' : ''}` }); 
dirBtn.innerHTML = Icons.arrowUpDown;
dirBtn.onclick = () => { state.sortDir = state.sortDir === 'asc' ? 'desc' : 'asc'; updateMenuVisuals(); renderApp(); };


// BOTTOM SECTION (FULL WIDTH)
// FILTER RANGES
const vmGroupRanges = menuContentGrid.createEl("div", { cls: "menu-group span-full" });
vmGroupRanges.createEl("div", { cls: "menu-label", text: "FILTER RANGES" });
const rowRanges = vmGroupRanges.createEl("div", { cls: "ranges-grid" });

// Helper for Dual Slider
const createDualSlider = (parent, title, min, max, step, stateKey) => {
    const box = parent.createEl("div", { cls: "range-control dual" });
    const [cMin, cMax] = state[stateKey];
    box.innerHTML = `
        <div class="range-header"><span>${title}</span><span class="range-value">${cMin} - ${cMax}</span></div>
        <div class="dual-range-wrapper">
            <div class="slider-track"></div>
            <input type="range" class="range-min" min="${min}" max="${max}" step="${step}" value="${cMin}">
            <input type="range" class="range-max" min="${min}" max="${max}" step="${step}" value="${cMax}">
        </div>`;
    
    const rangeMin = box.querySelector('.range-min');
    const rangeMax = box.querySelector('.range-max');
    const track = box.querySelector('.slider-track');
    const label = box.querySelector('.range-value');

    const updateSlider = () => {
        let v1 = parseFloat(rangeMin.value);
        let v2 = parseFloat(rangeMax.value);
        if (v1 > v2) { let temp = v1; v1 = v2; v2 = temp; }
        state[stateKey] = [v1, v2];
        label.innerText = `${v1} - ${v2}`;
        const percent1 = ((v1 - min) / (max - min)) * 100;
        const percent2 = ((v2 - min) / (max - min)) * 100;
        track.style.background = `linear-gradient(to right, rgba(255,255,255,0.1) ${percent1}%, var(--accent) ${percent1}%, var(--accent) ${percent2}%, rgba(255,255,255,0.1) ${percent2}%)`;
        debouncedRender();
    };

    rangeMin.oninput = updateSlider;
    rangeMax.oninput = updateSlider;
    
    // Init Visuals
    const p1 = ((cMin - min) / (max - min)) * 100;
    const p2 = ((cMax - min) / (max - min)) * 100;
    track.style.background = `linear-gradient(to right, rgba(255,255,255,0.1) ${p1}%, var(--accent) ${p1}%, var(--accent) ${p2}%, rgba(255,255,255,0.1) ${p2}%)`;
};

createDualSlider(rowRanges, "Personal Score", 0, 5, 0.1, "rangeMy");
createDualSlider(rowRanges, "Publication Year", 1920, 2030, 1, "rangeYear");


// GENRES & COLLECTIONS
const vmGroup3 = menuContentGrid.createEl("div", { cls: "menu-group span-full" });
vmGroup3.createEl("div", { cls: "menu-label", text: "FILTERS & GENRES" });
const rowSpecial = vmGroup3.createEl("div", { cls: "chip-cloud special-row" });
const createCatChip = (container, txt, id, isSpecial = false) => {
    const btn = container.createEl("button", { cls: `menu-chip small cat-btn ${state.categoryMode === id ? 'active' : ''} ${isSpecial ? 'special' : ''}`, attr: {'data-id': id} });
    btn.textContent = txt;
    btn.onclick = () => { state.categoryMode = id; updateMenuVisuals(); renderApp(); };
};
createCatChip(rowSpecial, "All", "all", true);
createCatChip(rowSpecial, "Series", "series", true);
techFilters.forEach(tf => createCatChip(rowSpecial, tf, tf));
vmGroup3.createEl("div", { cls: "menu-separator" });
const rowGenres = vmGroup3.createEl("div", { cls: "chip-cloud" });
availableGenres.forEach(g => createCatChip(rowGenres, g, g));

// --- HELPER: UPDATE MENU VISUALS WITHOUT RE-RENDERING ---
function updateMenuVisuals() {
    if(state.showMenu) { viewMenu.classList.add('active'); btnViewMenu.classList.add('active'); }
    else { viewMenu.classList.remove('active'); btnViewMenu.classList.remove('active'); }

    if(state.viewMode === 'grid') {
        viewToggle.innerHTML = `${Icons.timeline} <span>Switch to Timeline</span>`;
        sliderContainer.style.opacity = "1";
        sliderContainer.style.pointerEvents = "auto";
    } else {
        viewToggle.innerHTML = `${Icons.grid} <span>Switch to Grid</span>`;
        sliderContainer.style.opacity = "0.4";
        sliderContainer.style.pointerEvents = "none";
    }

    viewMenu.querySelectorAll('.sort-btn').forEach(b => {
        if(b.dataset.id === state.sortMode) b.classList.add('active'); else b.classList.remove('active');
    });
    
    const dirB = viewMenu.querySelector('.sort-dir-btn');
    if(state.sortDir === 'desc') dirB.classList.add('active'); else dirB.classList.remove('active');

    viewMenu.querySelectorAll('.cat-btn').forEach(b => {
        if(b.dataset.id === state.categoryMode) b.classList.add('active'); else b.classList.remove('active');
    });
    
    viewMenu.querySelectorAll('.range-control.dual').forEach(box => {
        const minInput = box.querySelector('.range-min');
        const maxInput = box.querySelector('.range-max');
        const track = box.querySelector('.slider-track');
        const label = box.querySelector('.range-value');
        
        let min = parseFloat(minInput.min);
        let max = parseFloat(minInput.max);
        let v1 = parseFloat(minInput.value);
        let v2 = parseFloat(maxInput.value);
        
        label.innerText = `${v1} - ${v2}`;
        const p1 = ((v1 - min) / (max - min)) * 100;
        const p2 = ((v2 - min) / (max - min)) * 100;
        track.style.background = `linear-gradient(to right, rgba(255,255,255,0.1) ${p1}%, var(--accent) ${p1}%, var(--accent) ${p2}%, rgba(255,255,255,0.1) ${p2}%)`;
    });
}

// Global Click
document.addEventListener('click', (e) => {
    if(state.showMenu && !viewMenu.contains(e.target) && !btnViewMenu.contains(e.target)) {
        state.showMenu = false; updateMenuVisuals();
    }
});

const contentArea = root.createEl("div", { cls: "eth-content-area" });
// Ensure Content Area has min-height to prevent menu cropping
contentArea.style.minHeight = "80vh"; 

const sliderInput = sliderGroup.querySelector('input'); 
sliderInput.oninput = (e) => { state.gridSize = e.target.value; contentArea.style.setProperty('--grid-size', `${state.gridSize}px`); }; 
contentArea.style.setProperty('--grid-size', `${state.gridSize}px`);
const debouncedRender = debounce(() => renderApp(), 300); 

function renderTimeline(pages) { const timelineEvents = []; pages.forEach(p => { const m = getMovieData(p); if (m.readDateObjs.length > 0) m.readDateObjs.forEach(date => timelineEvents.push({ date: date, movie: m, isReadDate: true })); else if (m.status === CONFIG.statusRead && m.created) timelineEvents.push({ date: m.created, movie: m, isReadDate: false }); }); timelineEvents.sort((a, b) => b.date - a.date); if (timelineEvents.length === 0) return `<div class="eth-empty-state">No timeline data available.</div>`; let html = `<div class="eth-timeline-stream">`; let currentGroup = ""; timelineEvents.forEach(ev => { const key = ev.date.toLocaleString('en-US', { month: 'long', year: 'numeric' }); if (key !== currentGroup) { if (currentGroup !== "") html += `</div></div>`; html += `<div class="stream-group"><div class="stream-header"><span class="sh-dot"></span> ${key}</div><div class="stream-grid">`; currentGroup = key; } const dayNumber = ev.date.getDate(); const dayName = ev.date.toLocaleDateString('en-US', { weekday: 'short' }); html += `<div class="stream-card" onclick="openMovieModalFromTimeline('${ev.movie.file.path}')"><div class="st-poster" style="background-image: url('${ev.movie.cover}')"><div class="st-date-badge"><b>${dayNumber}</b><span>${dayName}</span></div></div><div class="st-info"><div class="st-title">${ev.movie.title}</div><div class="st-meta">${ev.movie.year} ‚Ä¢ <span style="color:${ev.movie.color}">${ev.movie.mainGenre}</span></div><div class="st-rating">${ev.movie.score > 0 ? '‚òÖ ' + ev.movie.score : ''}</div></div></div>`; }); html += `</div></div></div>`; return html; }
window.openMovieModalFromTimeline = (path) => { const page = app.metadataCache.getFirstLinkpathDest(path, ""); const m = getMovieData({file: page, ...dv.page(path)}); openMovieModal(m); };

function renderApp() { 
    updateMenuVisuals(); 
    contentArea.innerHTML = ""; contentArea.className = `eth-content-area view-${state.viewMode}`; 
    let pages = rawPages; 
    if (state.search) pages = pages.where(p => p.file.name.toLowerCase().includes(state.search.toLowerCase())); 
    if (state.viewMode === 'timeline') { contentArea.innerHTML = renderTimeline(pages); return; } 
    const displayItems = processItems(pages, state.sortMode, state.sortDir, state.viewMode, state.categoryMode); 
    if (state.filter === 'lists' && (!displayItems || displayItems.length === 0 || displayItems[0].type !== 'createListCard')) { displayItems.unshift({ type: 'createListCard' }); }
    if (!displayItems || displayItems.length === 0) { contentArea.innerHTML = `<div class="eth-empty-state">No movies found.</div>`; return; } 
    displayItems.forEach(item => { 
        if (item.type === 'createListCard') {
            const card = contentArea.createEl("div", { cls: "eth-card create-list-card" });
            card.innerHTML = `<div class="create-icon-wrap">${Icons.plus}</div><div class="create-text">Create New Shelf</div>`;
            card.onclick = () => openCreateListModal();
        } 
        else if (item.type === 'stack' || item.type === 'userList') { 
            const card = contentArea.createEl("div", { cls: "eth-card stack-card" }); 
            
            // IMPORTANT: Inject specific color variable for CSS to use on hover
            card.style.setProperty('--accent', item.color);

            const badgeText = item.type === 'userList' ? 'LIST' : 'SERIES';
            const deleteBtn = item.type === 'userList' ? `<div class="stack-delete-btn" title="Delete Shelf">${Icons.trash}</div>` : '';
            const subText = item.type === 'userList' ? (item.desc || '') : (item.desc || 'Series');

            // SIMPLIFIED HTML: Removed stack-layer divs for cleaner classic look
            card.innerHTML = `
            <div class="eth-card-cover">
                <div class="stack-main-poster" style="background-image: url('${item.cover}')">
                    <div class="eth-card-overlay">
                        <div class="eth-play-circle sm">OPEN</div>
                    </div>
                    <div class="stack-top-badge">${badgeText}</div>
                    ${deleteBtn}
                    <div class="stack-glass-bar">
                        <div class="sgb-info">
                            <span>${Icons.layers} ${item.count} Movies</span>
                            <span class="sgb-count">${item.read}/${item.count}</span>
                        </div>
                        <div class="sgb-track">
                            <div class="sgb-fill" style="width: ${item.progress}%; background:${item.color}"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="eth-card-meta">
                <div class="title">${item.title}</div>
                <div class="sub" style="color:${item.color}">${subText}</div>
            </div>`;

            const delBtnEl = card.querySelector('.stack-delete-btn'); if(delBtnEl) { delBtnEl.onclick = (e) => { e.stopPropagation(); deleteList(item.id, item.title); }; }
            card.onclick = () => openSeriesModal(item); card.onmouseenter = () => { ambientBg.style.backgroundImage = `url('${item.cover}')`; ambientBg.classList.add('active'); }; card.onmouseleave = () => { ambientBg.classList.remove('active'); }; 
        } else { 
            const m = item.data; const isMasterpiece = m.score >= 4.5; const card = contentArea.createEl("div", { cls: isMasterpiece ? "eth-card masterpiece" : "eth-card" }); 
            
            // Inject dynamic color variable
            card.style.setProperty('--accent', m.color); 
            
            const badgeHtml = m.badges.length > 0 ? `<div class="card-badges">${m.badges.slice(0,2).map(b=>`<span>${b}</span>`).join('')}</div>` : ''; 
            card.innerHTML = `<div class=\"eth-card-cover\" style=\"background-image: url('${m.cover}')\"><div class=\"eth-card-overlay\"><div class=\"eth-play-circle\" style=\"color:${m.color}\">${Icons.play}</div></div>${m.score > 0 ? `<div class=\"eth-rating-badge\">${Icons.star} ${m.score}</div>` : ''}${badgeHtml}</div><div class=\"eth-card-meta\"><div class=\"title\" title=\"${m.title}\">${m.title}</div><div class=\"sub\">${m.year} ‚Ä¢ <span style=\"opacity:0.7; color:${m.color}\">${m.displayGenres}</span></div></div>`; 
            card.onclick = () => openMovieModal(m); card.onmouseenter = () => { ambientBg.style.backgroundImage = `url('${m.cover}')`; ambientBg.classList.add('active'); }; card.onmouseleave = () => { ambientBg.classList.remove('active'); }; 
        } 
    }); 
}
renderApp();
```
